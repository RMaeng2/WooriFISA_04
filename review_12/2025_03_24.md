### 우리FISA 12주차 학습기록

#### ( 2025.03.24 ~ 2025.03.28 )

---

##### 2025.03.24. Mon

#### JAVASCRIPT

인터프리터 언어 (스크립트 언어)
에러가 나면 바로 고칠 수 있어서 헐렁하게 코딩 가능
유연성이 있다.
엔진만 있다면 가볍게 돌아간다.
가벼운 프로그램에 많이 이용된다. VSCode도 자바스크립트로 만들어짐.

> 1995년에 나온 프로그래밍 언어
> 엔진(브라우저라면 내장 엔진)이 스크립트를 읽는다.
> 사용하는 모든 브라우저에서는 자바스크립트의 엔진이 내장되어 있다.
> 초창기 이름은 모카였으나 당시 핫했던 자바와 이름을 비슷하게 하여 마케팅을 하고자 해서 자바스크립트가 됨.

**ECMAScript**
자바스크립트를 표준 관리하는 단체
Ecma International에 의해 제정된 범용 스크립트 언어이고, Javascript는 ECMAScript 사양을 준수하는 스크립팅 언어.

사용자에게 서비스를 제공하는 프로그램이라면 자바스크립트를 안거치는 프로그램은 없다.

실습은 runjs playground에서 실행

**내장객체**
브라우저객체모델(BOM)
문서객체모델(DOM)

**Same Origin Policy**
서버에서 오는 하드들이 우리의 운영체제에 접근할 수 없도록 되어있다.

---

여러줄 주석 /\* \*/
한줄 주석 //

브라우저 엔진의 화면 랜더링 순서
html -> CSS -> JS
하나의 파일에 이 코드들을 작성할 때는 BODY의 맨 마지막 `<script></script>` 사이에 작성

**1. 변수**
선언과 할당으로 변수를 만들 수 있다.
변수를 얼만큼 갈아끼울 지 정함

1. var (방, 내용 갈아끼울 수 있음)
   자바스크립트의 제일 기본적인 변수 선언 키워드
   언제든 재선언, 재할당이 가능하다.
   var a; -> 선언
   a = 1; -> 할당

2. let (방은 만들고 내용은 갈아까울 수 있는)
   재선언은 불가능, 재할당은 가능
   let a; // 선언
   console.log(a); // undefined
   a = 1; // 할당

3. const (방도 방에 있는 기본 자료형도 갈아끼울 수 없도록록)
   const : constant 상수처럼 한번 선언한 방에 값을 다시 바꿀 수 없다. (기본자료형에 대해서)
   선언과 할당을 동시에 해야지 방이 만들어진다.
   참조 자료형을 const로 선언하고 이미 있는 key의 value를 변경하는 건 가능
   // const person = {name : "Yeonji"} // 참조자료형을 const로 선언
   // person.name = "jjangu" // 이미 있는 key의 value를 변경 가능
   // console.log(person)

;(세미콜론)은 줄 당 하나씩 작성하는 게 원칙이다. 안 적어줘도 되긴 하는데..

**왜 let과 const가 생겼을까?**
여러 사람이 작업 시 변수가 재선언, 재할당 되는 것을 막기 위해서
그래서 var는 권장되지 않는다.
웬만하면 const로 만들고 변경이 필요한 변수들은 let으로 바꾸기

**2. 변수 명명규칙(naming rules)**

- 변수는 camelCase 또는 snake_case를 권장한다.
- class를 만들 때는 PascalCase 사용
- 숫자, \_, \$을 변수에 사용 가능하나 맨 앞에 숫자로는는 시작할 수는 없다.

$ : 특별변수
\_ : 개발자만 쓴다.

공백, 마침표, 자바스크립트가 이미 쓰는 keyword(예약어)는 불가능하다.

<br>

**3. 자료형**

- 기본자료형(primative, 원시자료형), 참조자료형(object로 찍힘, reference)
- number (숫자)
  정수, 실수, 지수 표기법 가능
- string (문자열)
- boolean : true, false로 반환 (자바스크립트는 소문자로 반환)
- null : 값이 없음, 자료형은 object로 찍힘, 웬만해서 우리가 작성하는 빈 방에는 null을 채워 넣는 것이 좋음
  null은 숫자형 변환시 0으로 변환이 된다.
  null 은 완전항등연산자로 값을 비교한다.
- undefined : 정의되지 않음 (python의 None과 같다.)
  < undefined가 나오는 경우 - 화면단에 오류를 내지 않기 위해 >
  - 값을 대입하지 않은 변수
  - 리턴이 없는 함수의 실행 결과
  - 존재하지 않는 속성을 가리킬 때(잘못된 인덱스 가리킬 때)
- symbol : 고유하고 변경할 수 없는 값. 만약 같은 값을 선언해도 값 자체는 똑같더라도 다른 메모리에 들어가게 됨
- object : 객체 (배열, 날짜, 함수, Map, Set, 정규식)

**Object 자세히**

**1. 배열**

- 순서대로 값을 저장
- 집합 자료형
- 순서대로 값을 꺼낼 수 있다. (index로)
- 자바스크립트의 배열 index는 0부터 시작된다.

< 배열 만드는 방법 >
var array = []
var array2 = Array()
var array3 = new Array()

array1.push('donut'); // 맨 뒤에 값 추가
array1.unshift('a'); // 맨 앞에 값 삭제
array1.pop();// 맨 뒤의 값 삭제
array1.shift();// 맨 앞의 값 삭제
array1[2] = 'cat' // 값 수정
array1.sort() // 정렬: 결과를 자기 자신에게 리턴 0 파괴적인 함수

Number(null)은 0으로 형변환
NaN는 숫자가 아닌 걸 숫자로 형변환하려고 할 때 변환되는 number 자료형의 특수값
원래 어떤 값이 들어왔는지 알 수 없기 때문에 예외적으로 false가 나온다.

음수인덱싱, 슬라이싱이 불가능 하나 splice()를 통해 가능하다.
splice(시작점, 삭제할 개수, 삽입할 값1, 삽입할 값2 ...)
arr.splice(3, 1)

**Set(집합)** (js가 제공) - 중복을 걸러내는 유형.new Set [1, 2, 3, 4, 5, 6]
size - 원소의 개수 확인
add - 원소 삽입
delete - 원소 삭제

Dict (js 제공 X) - 따로 자료형으로 불리우지는 않고 Object type인데 key로 value를 부르는 종류의 object 타입을
var dict1 = {'가': '가위', '나':'나비', '다':'다람쥐', 1:1010, true:{1:'가'}, }
dict1['가'] // dict['key']
dict1.가
Object.keys(dict1) // key만
Object.values(dict1) // value만
'나비' in dict1 // false dict에서는 key 중심으로 움직이기 때문
'나' in dict1 // true
Object.entries(dict1) // [[key1, value1], [key2, value2] ....)
dict1['나'] = '나풀나풀' // 이미있는 key면 수정
dict1['마'] = '마이마이' // 없는 key면 삽입
delete dict1['마'] // dict 안의 key 삭제
console.log(dict1.size) // undefined
dict1[{'x':1}] = 300

<br>

Map : dictionary와 마찬가지로 키-값으로 쌍을 저장한다. 키로 값을 꺼내 쓴다.

- 키로 모든 데이터 타입을 받아준다.
- 삽입된 순서대로 요소를 반복할 수 있다.
- size 속성을 사용해서 요소의 개수를 확인할 수 있다.
- set(), get()으로 삽입, 조회를 할 수 있다.
- 뎁스가 깊거나 복잡하거나, 데이터의 입력 순서, 양이 많을 때

map1.set({x:1}, 'value3')
map1.get({x:1}) // 안 나옴
const a = {x:1}; // {x:1} 자체가 참조 자료형이기 때문에 메모리 주소로 비교 그래서 false 나옴
const b = {x:1};
a === b // false
map1.set(a, 369)
map1.get(a)

---

**조건, 반복, 클래스, 함수**

1. alert() - 출력만 가능한 팝업을 띄우는 함수, 자바스크립트의 브라우저가 제공하는 함수
2. confirm() - true, false 값만 입력받을 수 있다.
3. propt() - 값을 직접 입력 받을 수 있다. (python의 input())

1 == '1' - 항등연산자 : 값만 비교, 동등성
1 === '1' - 완전항등연산자 : 값과 자료형을 같이 비교
null은 완전 항등연산자로 값을 비교한다.

**연산자 우선순위 - 다른언어와 같다**
몫연산자가 없다.
증감연산자를 전위식, 후위식으로 사용할 수 있다.
완전항등연산자가 있다.

1. ( )- 감싸준 연산자가 제일 상위에 동작
2. \*\* 제곱
3. \-, 음수부호
4. \* / %(나머지)
5. +, - 연산이 동작합니다.
6. ++, -- a -= 1 a--(후위식) / --a(전위식)
7. Math.trunc() 몫연산

var a = 0;
++ a; // 전위식 : 더하고서 현재 코드줄에서 사용 a+++;불가
a--; // 후위식 : 쓰고서 다시 a라는 변수에게 돌려줄 때 빼고 돌려줌
--a;
a+=2; // a= a+2
a\*=2;
a/=2;
a%=2; // 나머지연산
Math.trunc(7/2);

**비교연산자**
== (항등연산자, 동등성 비교): 자료형 혹은 값이 같은지
=== (완전항등연산자, 동일성 비교) : 자료형, 값까지 비교

**논리 연산자 &&(and), ||(or), |(not)**

**if문**
if (조건) {
if 조건 해당 시 실행문
} else if (조건) {
else if 조건 해당 시 실행문
} else (조건) {
나머지 해당 시 실행문
}

**switch-case문**
switch (명제) {
case(1):
조건 만족시 실행문
break;
case(2):
조건 만족시 실행문
break;
default:
위의 모든 조건을 만족하지 못할 경우 실행문
break; // 어차피 마지막이라 안 걸어도 되긴 함
}

case문은 단일값을 비교하기 위해 만들어진 구문이라 ||, && 사용이 불가하다.

// 삼항연산자 - 불표현식 ? 참 : 거짓
hours < 12 ? '오전입니다.' : '오후입니다.'

js의 함수선언 function

BOM (Browser Object Model)

1. window 객체
2. screen 객체
3. location 객체
4. navigator 객체

자바스크립트는 만능이라서 웹에도 쓰고 백엔드에도 쓰고 유연하게 사용되기 때문에..

defer를 달아주거나

Object(객체) 중 하나인 배열

- 순서대로 값을 저장
- 집합 자료형
- 순서대로 값을 꺼낼 수 있다. (index)로
- 자바스크립트의 배열 index는 0부터 시작된다.

**자바스크립트의 신기한 특징**
NaN는 숫자가 아닌 걸 숫자로 형변환하려고 할 때 변환되는 number 자료형의 특수값
원래 어떤 값이 들어왔는지 알 수 없기 때문에 예외적으로 false가 나온다.
`NaN === NaN // 출력값 : false`

---

#### 우리FISA 48일차 KPT

Keep : 수업 집중력이 좋았다.

Problem : 중간중간 졸려서 수업 집중력이 흐트러졌다.

Try : 모르는 것이나 헷갈리는 부분들은 바로 정리하기, 시간이 없다면 모르는 부분 메모해 놓고 나중에라도 정리하기
