### 우리FISA 12주차 학습기록

#### ( 2025.03.24 ~ 2025.03.28 )

---

##### 2025.03.25.Tue

JAVASCRIPT 반복문

**반복문 for/while**

for(초기값; 조건; 증강식) {
반복되어야 할 실행문
}

배열의 길이는 .length라는 속성으로 확인

while문 - 반복할 횟수가 정해지지 않았을 때

1. while문 바깥에 조건을 끝낼 실마리를 만들어주고
2. 무한반복으로 작성하고 break, continue로 강제로 흐름을 제어하거나

while(명제){
명령문
}

forEach : 인덱스를 경유하지 않고 바로 값만 출력하는 메서드
for ... of : 인덱스를 경유하지 않고 각 원소에 직접 접근
반복 가능한 객체에 직접 적용가능

**함수**
함수 : 코드를 재사용하기 위해 쓴다.
function 함수명(파라미터1, 파라미터2, 파라미터3 ... ) {
파라미터를 받아서 실행할 실행문
return 실행 후 달고 돌아갈 값을 덩어리로 묶어서 한개로 전달
}

람다.. 이해 못함
함수명을 생략하고도 함수를 만들 수 있다. 익명함수처럼
`var hi2 = function (name) { // 함수명을 생략하고도 함수를 만들 수 있다. 익명함수처럼
  return `${name}아 안녕`
}`

화살표 함수도 있다.

`var hi3 = (name) => { // 화살표 함수도 있다.
  return `${name}아 안녕`
}`

기본 파라메터(default parameter)
파라미터도 리턴도 X 함수 (실행만 하고 끝)
파라미터가 있고 리턴은 X (실행만 하고 끝)
파라미터 X, 리턴은 O (return 달고 실행줄로 돌아감)
파라미터 O, 리턴도 O (입력받은 값을 실행줄로 변환시켜서 return 뒤에 달아서 돌아감)

작성한 파라미터 개수와 맞지 않아도 undefined를 넣어서 동작

packing, unpacking ...(spread 연산자를 가지고 똑같은 작업을 할 수 있다.)

1. 스코프 : 변수나 함수가 어디까지 접근해서 사용할 수 있는지.
2. 호이스팅(Hoisting): 변수나 함수의 선언이 스코프의 최상단에서 먼저 읽은 것처럼 동작하는 것.

- 호이스팅은 선언만 끌어올려지고, 값은 끌어올려지지 않습니다.

3. TDZ(Temporal Dead Zone): 변수가 선언되기 전까지 접근할 수 없는 구간

| 키워드  | 스코프 범위    | 재선언 | 재할당 | 호이스팅 | 특징 요약                          |
| ------- | -------------- | ------ | ------ | -------- | ---------------------------------- |
| `var`   | 함수 스코프    | O      | O      | O        | 블록 무시, 중복 선언 가능          |
| `let`   | 블록 스코프 {} | X      | O      | O (TDZ)  | 블록 안에서만 유효, 중복 선언 불가 |
| `const` | 블록 스코프 {} | X      | X      | O (TDZ)  | 상수 선언, 객체 내부 변경 가능     |

**호이스팅**
써놓은 코드보다 앞에서 실행하면 파이썬으 ㄴ에러를 내지만 자바스크립트는 되도록 에러를 내지 않는 쪽으로 설계가 됐기 때문에 적어놓은 코드보다 먼저 불러와도 미리 메모리에 변수, 함수들을 현재 범위(스코프)내에서 최상단에 있는 것처럼 끌어올려서 동작시키는 자바 스크립트 엔진의 기능이다.

변수의 호이스팅 : 선언만을 끌어올리기 때문에 할당된 값까지는 끌어올리지 않기 때문에 var의 경우에는 undefined, let / const의 경우에는 ReferenceError가 난다.

함수의 호이스팅 : function 키워드로 작성한 함수는 모든 코드가 최상단에 끌어올려지므로 작성해놓은 코드 줄 앞에서도 실행된다. 하지만 var, let, const로 익명함수나 화살표 함수를 변수명에 달아놓은 경우에는 앞에서 실행되지 않는다.

**클래스**
같은 형식으로 사용하기 위한 자료형을 미리 만들어놓고 계속 객체를 찍어서 재사용

- 같은 자료형으로 데이터를 관리하기 위한 자료형의 자료형(틀)입니다.

함수처럼 동작한다.

- function으로 만들어진다.
- 다른 언어와 호환되다 보니까 class 클래스명으로 만들면 내부적으로 코드를 변환해서 동작시켜준다.

클래스를 통해 접근하는 클래스 변수, 클래스 메서드
인스턴스를 통해 접근하는 인스턴스 변수, 인스턴스 메서드
sugar coated 문법

인스턴스메소드는 prototype으로 넘겨줌

this = 현재 속성, 함수가 위치하는 메모리 주소 자체

- class 클래스명 { #변수명; // 선언만 해주시면
  // 클래스 변수
  static 변수명
  // 클래스 함수
  static 함수명() {
  }
  // 인스턴스 변수
  constructor(파라미터1, 파라미터2, 파라미터3) {
  this.파라미터1 = 파라미터1
  this.파라미터2 = 파라미터2
  this.#파라미터3 = 파라미터3 // #키워드로 외부에서 접근 불가능한 속성을 만들 수 있습니다.
  }
  // 인스턴스 함수
  함수명() {
  실행문
  return 결과
  }
  // @getter
  // 외부에는 변수명을 알려주지 않고 다른 이름으로 쓰고 싶은것
  get 함수명() {
  실행문으로 조회 가능
  }
  // @함수명.setter
  set 함수명(바뀔값) {
  실행문을 변수처럼 접근해서 사용할 수 있도록
  }
  }

**네?**

**이벤트 핸들러**

---
